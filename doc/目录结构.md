# 目录结构
``````js
{
    gate: { // package gate
        gate.go: {
            // 定义*gate.Gate对象


            // 定义*gate.agent对象，实现*gate.Agent接口
            type agent struct {
                conn     network.Conn // *network.TCPConn对象
                gate     *Gate        // 关联的*gate.Gate对象
                userData interface{}
            }
        },
        agent.go: {
            // 定义*gate.Agent接口
            type Agent interface {
                WriteMsg(msg interface{})
                LocalAddr() net.Addr
                RemoteAddr() net.Addr
                Close()
                Destroy()
                UserData() interface{}
                SetUserData(data interface{})
            }
        }
    }
    network: { // package network
        json: { // package network/json
            json.go: {
                // 定义*json.Processor
                type Processor struct {
                    msgInfo map[string]*MsgInfo
                }
                // 定义*json.MsgInfo
                type MsgInfo struct {
                    msgType       reflect.Type
                    msgRouter     *chanrpc.Server
                    msgHandler    MsgHandler
                    msgRawHandler MsgHandler
                }
            }
        }
        tcp_msg.go: {
            // 定义*network.MsgParser，作为*network.TCPServer的msgParser属性
            // *network.MsgParser：处理消息封包和拆包
        }
        tcp_server.go: {
            // 定义*network.TCPServer,
            // *network.TCPServer.run()方法中会新建一个*gate.agent对象，并在go协程中调用*gate.agent.Run()
        }
        tcp_conn.go: {
            // 定义*network.TCPConn
            // 封装底层net.Conn，提供经过msgParser处理过的数据读写方法ReadMsg()，WriteMsg()
            // 向底层连接net.Conn写数据额外提供了一层缓冲写通道
        }
    }
}
``````js

# leafserver/src/client/main.go中发送的消息如下
	data := []byte(`{
		"Hello": {
			"Name": "leaf"
		}
	}`)

# *agent.Run()逻辑

## *network.MsgParser.Read()读取到的数据如下：
[]uint8 len: 39, cap: 39, [123,10,9,9,34,72,101,108,108,111,34,58,32,123,10,9,9,9,34,78,97,109,101,34,58,32,34,108,101,97,102,34,10,9,9,125,10,9,125]
其string()表达如下：
"{\n\t\t\"Hello\": {\n\t\t\t\"Name\": \"leaf\"\n\t\t}\n\t}"

## *network/json/json.go中*Processor.Unmarshal(data)获取到的m数据如下：
map[string]encoding/json.RawMessage ["Hello": [123,10,9,9,9,34,78,97,109,101,34,58,32,34,108,101,97,102,34,10,9,9,125], ]
上述"Hello"键对应的值得string()表达如下：
"{\n\t\t\t\"Name\": \"leaf\"\n\t\t}"

## 经过msg, err := a.gate.Processor.Unmarshal(data)后，msg值为：
 interface {}(*server/msg.Hello) *{Name: "leaf"}

## err = a.gate.Processor.Route(msg, a)
最终会走到leafserver/src/gate/router.go中为msg.Hello{}注册的路由game.chanRPC中
然后走到submodules\leafserver\src\server\game\internal\handler.go中的handleHello()方法中，其中args参数为：
[]interface {} len: 2, cap: 2, [*server/msg.Hello {Name: "leaf"},*github.com/name5566/leaf/gate.agent {conn: github.com/name5566/leaf/network.Conn(*github.com/name5566/leaf/network.TCPConn) ..., gate: *(*"github.com/name5566/leaf/gate.Gate")(0xc0000d41b0), userData: interface {} nil}]
其中m值为：
*server/msg.Hello {Name: "leaf"}
然后调用agent.WriteMsg()，实际上是agent.conn.WriteMsg()回复消息给客户端
最终调用的是*network.TCPConn.WriteMsg()

# 消息流转

## 服务器接受消息
*gate.agent.Run() => *gate.agent.conn.ReadMsg()

## 服务器处理消息，并回复消息到客户端调用流程
*gate.agent.Run() => *gate.Gate.Processor.Route()[实际是*network/json.Processor.Route()] => game.ChanRPC => *server/game/internal.handleHello() => *gate.agent.WriteMsg()[*gate.agent没有定义WriteMsg()，继承自*network.TCPConn.WriteMsg()] => *network.TCPConn.WriteMsg() => *network.MsgParser.Write() => *network.TCPConn.Write() => *network.TCPConn.doWrite() => 写入*network.TCPConn.writeChan

## 客户端Ctrl+C发送SIGINT中断信号断开连接时
*gate.agent.Run() => a.conn.ReadMsg()报错error(*os.SyscallError) *{Syscall: "wsarecv", Err: error(syscall.Errno) WSAECONNRESET (10054)}终止*gate.agent.Run() => *network.TCPServer.run()的go协程中 => 执行cleanup操作