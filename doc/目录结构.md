# 目录结构
``````js
{
    module: { // package module
        skeleton.go: {
            
        }
    }
    chanrpc: { // package chanrpc
        // 包含一组函数映射[id为消息类型，值为该消息的处理函数]
        type Server struct {
            // id -> function
            //
            // function:
            // func(args []interface{})
            // func(args []interface{}) interface{}
            // func(args []interface{}) []interface{}
            functions map[interface{}]interface{}
            ChanCall  chan *CallInfo
        }
        // 调用Go()方法时，会将需要调用的函数和参数组合成*chanrpc.CallInfo对象，发送到*chanrpc.Server.ChanCall缓冲通道中，再由*module.Skeleton.Run()方法负责通*chanrpc.Server.ChanCall缓冲通道中接受数据处理，最终会调用*chanrpc.Server.Exec()来处理这个*chanrpc.CallInfo对象
    }
    gate: { // package gate
        gate.go: {
            // 定义*gate.Gate对象，除绑定一堆TCP配置外，，最重要的是初始化Processor和AgentChanRPC
            // 在编写游戏服务器的gate模块时，除了新建gate模块外【类似leafserver/src/server/gate/external.go】，还需要为每种消息设置处理消息的路由【类似leafserver/src/server/gate/route.go】


            // 定义*gate.agent对象，实现*gate.Agent接口
            type agent struct {
                conn     network.Conn // *network.TCPConn对象
                gate     *Gate        // 关联的*gate.Gate对象
                userData interface{}
            }
        },
        agent.go: {
            // 定义*gate.Agent接口
            type Agent interface {
                WriteMsg(msg interface{})
                LocalAddr() net.Addr
                RemoteAddr() net.Addr
                Close()
                Destroy()
                UserData() interface{}
                SetUserData(data interface{})
            }

            func (a *agent) Run() {
                for {
                    // 无限循环调用*network.TCPConn.ReadMsg()读取经过msgParser解析后的数据
                    // 调用*gate.agent.Processor.Unmarshal(data)反序列化数据
                    // 调用*gate.agent.ProcessorRoute(msg, a)处理数据,一般会将消息的路由设置为game.ChanRPC, game.ChanRPC一般在game模块中定义，实际上是一个chanrpc.NewServer()对象
                    // 因为一个msg对应的路由为一个*chanrpc.Server对象，上述ProcessorRoute()方法会调用*chanrpc.Server.Go()
                    // *chanrpc.Server.Go()会调用leafserver/src/server/game/internal/handler.go中为消息注册的处理函数handleHello()中
                    // 消息处理函数处理完后会将处理结果，调用*gate.agent.WriteMsg()写入，最终是调用*network.TCPConn.WriteMsg()写入结果
                }
            }
        }
    }
    network: { // package network
        json: { // package network/json
            // 实现了*network.Processor接口的一个具体的Processor对象，外部可以通过var Processor = json.NewProcessor()获得
            json.go: {
                // Processor定义了一组字符串到*MsgInfo的映射
                // 主要负责为各种消息设置路由，其Route()方法最终会调用消息路由[通常是一个*chanrpc.Server对象]的Go方法执行消息处理逻辑
                type Processor struct {
                    msgInfo map[string]*MsgInfo
                }
                // 定义*json.MsgInfo
                type MsgInfo struct {
                    msgType       reflect.Type    // 消息类型
                    msgRouter     *chanrpc.Server // 消息路由
                    msgHandler    MsgHandler      // 消息处理方法
                    msgRawHandler MsgHandler      // 消息原始处理方法
                }
            }
        }
        tcp_msg.go: {
            // 定义*network.MsgParser，作为*network.TCPServer的msgParser属性
            // *network.MsgParser：处理消息封包和拆包
        }
        tcp_server.go: {
            // 定义*network.TCPServer,
            // 负责监听本地网络地址，并管理底层连接net.Conn，为每一个连接创建一个agent，并在go协程中运行agent.Run()
            // *network.TCPServer.run()方法中会新建一个*gate.agent对象，并在go协程中调用*gate.agent.Run()
        }
        tcp_conn.go: {
            // 定义*network.TCPConn
            // 封装底层net.Conn，提供经过msgParser处理过的数据读写方法ReadMsg()，WriteMsg()
            // 向底层连接net.Conn写数据额外提供了一层缓冲写通道
        }
    }
    leafserver/src/：{
        game：{
            // game模块中会为每个消息注册消息处理函数，例如leafserver/src/server/game/internal/handler.go中所示
        }
    }
}
``````js

# leafserver/src/client/main.go中发送的消息如下
	data := []byte(`{
		"Hello": {
			"Name": "leaf"
		}
	}`)

# *agent.Run()逻辑

## *network.MsgParser.Read()读取到的数据如下：
[]uint8 len: 39, cap: 39, [123,10,9,9,34,72,101,108,108,111,34,58,32,123,10,9,9,9,34,78,97,109,101,34,58,32,34,108,101,97,102,34,10,9,9,125,10,9,125]
其string()表达如下：
"{\n\t\t\"Hello\": {\n\t\t\t\"Name\": \"leaf\"\n\t\t}\n\t}"

## *network/json/json.go中*Processor.Unmarshal(data)获取到的m数据如下：
map[string]encoding/json.RawMessage ["Hello": [123,10,9,9,9,34,78,97,109,101,34,58,32,34,108,101,97,102,34,10,9,9,125], ]
上述"Hello"键对应的值得string()表达如下：
"{\n\t\t\t\"Name\": \"leaf\"\n\t\t}"

## 经过*gate.agent.Run()中，msg, err := a.gate.Processor.Unmarshal(data)后，msg值为：
 interface {}(*server/msg.Hello) *{Name: "leaf"}

## err = a.gate.Processor.Route(msg, a)
最终会走到leafserver/src/gate/router.go中为msg.Hello{}注册的路由game.chanRPC中
然后走到submodules\leafserver\src\server\game\internal\handler.go中的handleHello()方法中，其中args参数为：
[]interface {} len: 2, cap: 2, [*server/msg.Hello {Name: "leaf"},*github.com/name5566/leaf/gate.agent {conn: github.com/name5566/leaf/network.Conn(*github.com/name5566/leaf/network.TCPConn) ..., gate: *(*"github.com/name5566/leaf/gate.Gate")(0xc0000d41b0), userData: interface {} nil}]
其中m值为：
*server/msg.Hello {Name: "leaf"}
然后调用agent.WriteMsg()，实际上是agent.conn.WriteMsg()回复消息给客户端
最终调用的是*network.TCPConn.WriteMsg()

# 消息流转

## 服务器接受消息
*gate.agent.Run() => *gate.agent.conn.ReadMsg()

## 服务器处理消息，并回复消息到客户端调用流程
*gate.agent.Run() => *gate.Gate.Processor.Route()[实际是*network/json.Processor.Route()] => game.ChanRPC => *server/game/internal.handleHello() => *gate.agent.WriteMsg()[*gate.agent没有定义WriteMsg()，继承自*network.TCPConn.WriteMsg()] => *network.TCPConn.WriteMsg() => *network.MsgParser.Write() => *network.TCPConn.Write() => *network.TCPConn.doWrite() => 写入*network.TCPConn.writeChan

## 客户端Ctrl+C发送SIGINT中断信号断开连接时
*gate.agent.Run() => a.conn.ReadMsg()报错error(*os.SyscallError) *{Syscall: "wsarecv", Err: error(syscall.Errno) WSAECONNRESET (10054)}终止*gate.agent.Run() => *network.TCPServer.run()的go协程中 => 执行cleanup操作